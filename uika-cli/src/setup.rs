// Setup command: extracts embedded UE plugin files into a UE project,
// generates starter config, registers plugins in .uproject, and writes C++ stubs.

use std::fs;
use std::path::Path;

include!(concat!(env!("OUT_DIR"), "/plugin_files.rs"));

const CSPROJ_PROPS_TEMPLATE: &str = r#"<Project>
  <PropertyGroup>
    <EngineDir>{engine_path}</EngineDir>
  </PropertyGroup>
</Project>
"#;

/// Starter uika.config.toml template.
/// `{engine_path}` and `{cpp_out}` are replaced at runtime.
const CONFIG_TEMPLATE: &str = r##"# Uika project configuration
# Generated by `uika setup`. Adjust paths for your environment.

[ue]
engine_path = "{engine_path}"

[project]
path = "{project_path}"

# --- Codegen configuration ---

[codegen]
features = ["core", "engine"]

[codegen.paths]
uht_input = "generated/uht"
rust_out = "uika-bindings/src"
cpp_out = "{cpp_out}"

[codegen.modules]
# UE Package name = { module = "rust_module", feature = "cargo_feature" }
CoreUObject = { module = "core_ue", feature = "core" }
Engine = { module = "engine", feature = "engine" }
PhysicsCore = { module = "physics_core", feature = "physics-core" }
InputCore = { module = "input_core", feature = "input" }
SlateCore = { module = "slate_core", feature = "slate" }
Slate = { module = "slate", feature = "slate" }
UMG = { module = "umg", feature = "umg" }
Niagara = { module = "niagara", feature = "niagara" }
GameplayAbilities = { module = "gameplay_abilities", feature = "gameplay-abilities" }
LevelSequence = { module = "level_sequence", feature = "level-sequence" }
CinematicCamera = { module = "cinematic_camera", feature = "cinematic" }
MovieScene = { module = "movie_scene", feature = "movie" }
MovieSceneTracks = { module = "movie_scene_tracks", feature = "movie" }

[codegen.blocklist]
classes = []
structs = []
functions = []
"##;

/// Stub UikaFuncIds.h — empty namespace with FUNC_COUNT = 0.
const STUB_FUNC_IDS_H: &str = "\
// Auto-generated stub by uika setup. Will be overwritten by codegen.

#pragma once

#include <cstdint>

namespace UikaFuncId {

    constexpr uint32_t FUNC_COUNT = 0;

} // namespace UikaFuncId
";

/// Stub UikaFillFuncTable.cpp — empty implementations.
const STUB_FILL_TABLE_CPP: &str = "\
// Auto-generated stub by uika setup. Will be overwritten by codegen.

#include \"UikaFuncIds.h\"

void UikaFillFuncTable() {}

static void* GUikaFuncTable[1]; // placeholder (FUNC_COUNT == 0)

void** UikaGetFuncTable() {
    return GUikaFuncTable;
}

uint32_t UikaGetFuncCount() {
    return 0;
}
";

/// Default module_deps.txt content for initial build.
const STUB_MODULE_DEPS: &str = "Core\nCoreUObject\nEngine";

pub fn run_setup(project_path: &Path, engine_path: &Path) {
    let plugins_dir = project_path.join("Plugins");

    // Validate project path looks reasonable
    if !project_path.exists() {
        eprintln!(
            "Error: project path does not exist: {}",
            project_path.display()
        );
        std::process::exit(1);
    }

    // Validate engine path
    if !engine_path.join("Engine").exists() {
        eprintln!(
            "Warning: {}/Engine/ not found. Make sure the engine path is correct.",
            engine_path.display()
        );
    }

    // --- Step 1: Write embedded plugin files ---
    eprintln!(
        "uika setup: writing {} plugin files...",
        PLUGIN_FILES.len()
    );

    let mut written = 0;
    for (rel_path, contents) in PLUGIN_FILES {
        let dest = plugins_dir.join(rel_path);
        if let Some(parent) = dest.parent() {
            fs::create_dir_all(parent)
                .unwrap_or_else(|e| panic!("Failed to create {}: {e}", parent.display()));
        }
        fs::write(&dest, contents)
            .unwrap_or_else(|e| panic!("Failed to write {}: {e}", dest.display()));
        written += 1;
    }

    // Generate .csproj.props with engine path
    let engine_path_str = engine_path.to_str().unwrap_or_else(|| {
        eprintln!("Error: engine path contains non-UTF8 characters");
        std::process::exit(1);
    });
    // Normalize to forward slashes for UBT compatibility
    let engine_path_normalized = engine_path_str.replace('\\', "/");

    let props_content = CSPROJ_PROPS_TEMPLATE.replace("{engine_path}", &engine_path_normalized);
    let props_path = plugins_dir
        .join("UikaGenerator/Source/UikaExporter/UikaExporter.ubtplugin.csproj.props");
    if let Some(parent) = props_path.parent() {
        fs::create_dir_all(parent)
            .unwrap_or_else(|e| panic!("Failed to create {}: {e}", parent.display()));
    }
    fs::write(&props_path, &props_content)
        .unwrap_or_else(|e| panic!("Failed to write {}: {e}", props_path.display()));

    eprintln!("  Wrote {} plugin files to {}", written, plugins_dir.display());
    eprintln!("  Generated {}", props_path.display());
    eprintln!("  Engine path: {}", engine_path_normalized);

    // --- Step 2: Generate uika.config.toml in CWD ---
    generate_config(project_path, &engine_path_normalized);

    // --- Step 3: Register plugins in .uproject ---
    register_uproject_plugins(project_path);

    // --- Step 4: Generate C++ stubs ---
    generate_cpp_stubs(project_path);

    eprintln!("uika setup: done!");
}

/// Generate a starter `uika.config.toml` in the current working directory (if it doesn't exist).
fn generate_config(project_path: &Path, engine_path: &str) {
    let config_path = Path::new("uika.config.toml");
    if config_path.exists() {
        eprintln!("  uika.config.toml already exists, skipping.");
        return;
    }

    // Build cpp_out relative path: {project_path}/Plugins/Uika/Source/Uika/Generated
    let cpp_out = project_path.join("Plugins/Uika/Source/Uika/Generated");
    let cpp_out_str = cpp_out.to_str().unwrap_or("Plugins/Uika/Source/Uika/Generated");
    let cpp_out_normalized = cpp_out_str.replace('\\', "/");

    // Build project_path string, normalized
    let project_path_str = project_path.to_str().unwrap_or(".");
    let project_path_normalized = project_path_str.replace('\\', "/");

    let content = CONFIG_TEMPLATE
        .replace("{engine_path}", engine_path)
        .replace("{cpp_out}", &cpp_out_normalized)
        .replace("{project_path}", &project_path_normalized);

    fs::write(config_path, &content)
        .unwrap_or_else(|e| panic!("Failed to write uika.config.toml: {e}"));

    eprintln!("  Generated uika.config.toml");
}

/// Find and update the .uproject file to include Uika and UikaGenerator plugins.
fn register_uproject_plugins(project_path: &Path) {
    // Find *.uproject in project directory
    let uproject_path = match find_uproject(project_path) {
        Some(p) => p,
        None => {
            eprintln!("  Warning: no .uproject file found in {}, skipping plugin registration.", project_path.display());
            return;
        }
    };

    // Read and parse JSON
    let content = fs::read_to_string(&uproject_path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {e}", uproject_path.display()));

    let mut doc: serde_json::Value = serde_json::from_str(&content)
        .unwrap_or_else(|e| panic!("Failed to parse {}: {e}", uproject_path.display()));

    let obj = doc
        .as_object_mut()
        .expect(".uproject root must be a JSON object");

    // Ensure "Plugins" array exists
    if !obj.contains_key("Plugins") {
        obj.insert(
            "Plugins".to_string(),
            serde_json::Value::Array(Vec::new()),
        );
    }

    let plugins = obj
        .get_mut("Plugins")
        .unwrap()
        .as_array_mut()
        .expect(".uproject Plugins must be an array");

    // Add missing plugin entries
    let required = ["Uika", "UikaGenerator"];
    let mut added = Vec::new();
    for name in &required {
        let already = plugins.iter().any(|p| {
            p.get("Name")
                .and_then(|v| v.as_str())
                .map_or(false, |n| n == *name)
        });
        if !already {
            plugins.push(serde_json::json!({
                "Name": name,
                "Enabled": true
            }));
            added.push(*name);
        }
    }

    // Write back formatted JSON
    let output = serde_json::to_string_pretty(&doc)
        .unwrap_or_else(|e| panic!("Failed to serialize .uproject: {e}"));
    fs::write(&uproject_path, output)
        .unwrap_or_else(|e| panic!("Failed to write {}: {e}", uproject_path.display()));

    if added.is_empty() {
        eprintln!(
            "  {} already has Uika plugins registered.",
            uproject_path.display()
        );
    } else {
        eprintln!(
            "  Registered plugins in {}: {}",
            uproject_path.display(),
            added.join(", ")
        );
    }
}

/// Generate C++ stub files so the first UE build can link before codegen runs.
fn generate_cpp_stubs(project_path: &Path) {
    let generated_dir = project_path.join("Plugins/Uika/Source/Uika/Generated");
    fs::create_dir_all(&generated_dir)
        .unwrap_or_else(|e| panic!("Failed to create {}: {e}", generated_dir.display()));

    let files: &[(&str, &str)] = &[
        ("UikaFuncIds.h", STUB_FUNC_IDS_H),
        ("UikaFillFuncTable.cpp", STUB_FILL_TABLE_CPP),
        ("module_deps.txt", STUB_MODULE_DEPS),
    ];

    for (name, content) in files {
        let path = generated_dir.join(name);
        fs::write(&path, content)
            .unwrap_or_else(|e| panic!("Failed to write {}: {e}", path.display()));
    }

    eprintln!(
        "  Generated C++ stubs in {}",
        generated_dir.display()
    );
}

/// Find the single .uproject file in a directory.
fn find_uproject(dir: &Path) -> Option<std::path::PathBuf> {
    let entries = fs::read_dir(dir).ok()?;
    let mut found = None;
    for entry in entries.flatten() {
        let path = entry.path();
        if path.extension().map_or(false, |ext| ext == "uproject") {
            found = Some(path);
            break;
        }
    }
    found
}
