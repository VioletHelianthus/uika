//! Generates `ffi_dispatch.rs` from `uika-ffi/src/api_table.rs`.
//!
//! For each sub-table function, generates:
//! - A dispatch wrapper that calls the API table on native or the WASM import on wasm32.
//! - (wasm32 only) An `extern "C"` import declaration.

use std::env;
use std::fmt::Write as FmtWrite;
use std::fs;
use std::path::Path;

use uika_api_parse::*;

fn main() {
    let api_table_path = Path::new("../uika-ffi/src/api_table.rs");
    println!("cargo:rerun-if-changed={}", api_table_path.display());

    let source =
        fs::read_to_string(api_table_path).expect("Failed to read api_table.rs");
    let tables = parse_api_table(&source);

    // Guest side: no NativePtr overrides. spawn_actor etc. pass transform_buf
    // through WASM memory as ptr+len (WasmBufRead), not as native pointers.
    let overrides = NativePtrOverrides::default();

    let mut output = String::new();
    writeln!(output, "// Auto-generated by uika-runtime/build.rs — do not edit").unwrap();
    writeln!(output, "// Source: uika-ffi/src/api_table.rs").unwrap();
    writeln!(output).unwrap();

    // Imports
    writeln!(output, "use uika_ffi::handles::*;").unwrap();
    writeln!(output, "use uika_ffi::error::UikaErrorCode;").unwrap();
    writeln!(output).unwrap();

    // NativePtr type alias (native pointers that can't be dereferenced on wasm32)
    writeln!(output, "/// Opaque native pointer: `*mut u8` on native, `u64` on wasm32.").unwrap();
    writeln!(output, "/// Only used for alloc_params/free_params/call_function etc.").unwrap();
    writeln!(output, "#[cfg(not(target_arch = \"wasm32\"))]").unwrap();
    writeln!(output, "pub type NativePtr = *mut u8;").unwrap();
    writeln!(output, "#[cfg(target_arch = \"wasm32\")]").unwrap();
    writeln!(output, "pub type NativePtr = u64;").unwrap();
    writeln!(output).unwrap();

    // NativePtr null helpers
    writeln!(output, "#[cfg(not(target_arch = \"wasm32\"))]").unwrap();
    writeln!(output, "pub const NATIVE_PTR_NULL: NativePtr = core::ptr::null_mut();").unwrap();
    writeln!(output, "#[cfg(target_arch = \"wasm32\")]").unwrap();
    writeln!(output, "pub const NATIVE_PTR_NULL: NativePtr = 0;").unwrap();
    writeln!(output).unwrap();
    writeln!(output, "#[inline(always)]").unwrap();
    writeln!(output, "pub fn native_ptr_is_null(p: NativePtr) -> bool {{").unwrap();
    writeln!(output, "    #[cfg(not(target_arch = \"wasm32\"))]").unwrap();
    writeln!(output, "    {{ p.is_null() }}").unwrap();
    writeln!(output, "    #[cfg(target_arch = \"wasm32\")]").unwrap();
    writeln!(output, "    {{ p == 0 }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Native memory read/write helpers (for DynamicCall on wasm32)
    writeln!(output, "/// Read `size_of::<T>()` bytes from native memory at `ptr + offset`.").unwrap();
    writeln!(output, "#[cfg(not(target_arch = \"wasm32\"))]").unwrap();
    writeln!(output, "#[inline(always)]").unwrap();
    writeln!(output, "pub unsafe fn native_mem_read<T: Copy>(ptr: NativePtr, offset: usize) -> T {{").unwrap();
    writeln!(output, "    core::ptr::read_unaligned(ptr.add(offset) as *const T)").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
    writeln!(output, "#[cfg(target_arch = \"wasm32\")]").unwrap();
    writeln!(output, "#[inline(always)]").unwrap();
    writeln!(output, "pub unsafe fn native_mem_read<T: Copy>(ptr: NativePtr, offset: usize) -> T {{").unwrap();
    writeln!(output, "    let mut value = core::mem::zeroed::<T>();").unwrap();
    writeln!(output, "    uika_read_native_mem(").unwrap();
    writeln!(output, "        (ptr + offset as u64) as i64,").unwrap();
    writeln!(output, "        &mut value as *mut T as i32,").unwrap();
    writeln!(output, "        core::mem::size_of::<T>() as i32,").unwrap();
    writeln!(output, "    );").unwrap();
    writeln!(output, "    value").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
    writeln!(output, "/// Write `size_of::<T>()` bytes of `value` to native memory at `ptr + offset`.").unwrap();
    writeln!(output, "#[cfg(not(target_arch = \"wasm32\"))]").unwrap();
    writeln!(output, "#[inline(always)]").unwrap();
    writeln!(output, "pub unsafe fn native_mem_write<T: Copy>(ptr: NativePtr, offset: usize, value: T) {{").unwrap();
    writeln!(output, "    core::ptr::write_unaligned(ptr.add(offset) as *mut T, value)").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
    writeln!(output, "#[cfg(target_arch = \"wasm32\")]").unwrap();
    writeln!(output, "#[inline(always)]").unwrap();
    writeln!(output, "pub unsafe fn native_mem_write<T: Copy>(ptr: NativePtr, offset: usize, value: T) {{").unwrap();
    writeln!(output, "    uika_write_native_mem(").unwrap();
    writeln!(output, "        (ptr + offset as u64) as i64,").unwrap();
    writeln!(output, "        &value as *const T as i32,").unwrap();
    writeln!(output, "        core::mem::size_of::<T>() as i32,").unwrap();
    writeln!(output, "    );").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Generate wasm32 extern imports block
    writeln!(output, "#[cfg(target_arch = \"wasm32\")]").unwrap();
    writeln!(output, "#[link(wasm_import_module = \"uika\")]").unwrap();
    writeln!(output, "unsafe extern \"C\" {{").unwrap();
    // Hand-written host functions for native memory access (DynamicCall)
    writeln!(output, "    // Native memory access (for DynamicCall on wasm32)").unwrap();
    writeln!(output, "    pub fn uika_read_native_mem(src: i64, dst: i32, len: i32);").unwrap();
    writeln!(output, "    pub fn uika_write_native_mem(dst: i64, src: i32, len: i32);").unwrap();
    writeln!(output, "    // Native struct alloc/free (for OwnedStruct on wasm32)").unwrap();
    writeln!(output, "    pub fn uika_struct_alloc(ustruct: i64) -> i64;").unwrap();
    writeln!(output, "    pub fn uika_struct_free(ustruct: i64, ptr: i64);").unwrap();
    writeln!(output, "    // Generic native alloc/free (for handle arrays, etc.)").unwrap();
    writeln!(output, "    pub fn uika_native_alloc(size: i32) -> i64;").unwrap();
    writeln!(output, "    pub fn uika_native_free(ptr: i64, size: i32);").unwrap();
    writeln!(output).unwrap();
    for table in &tables {
        for func in &table.functions {
            let import_name = format!("uika_{}_{}", table.module_name, func.name);
            let classes = classify_params(func, &table.module_name, &overrides);
            let ret_class = classify_return(&func.return_type);
            let wasm_params = build_wasm_import_params(&func.params, &classes);
            let wasm_ret = build_wasm_return_type(&func.return_type);
            write!(output, "    fn {import_name}(").unwrap();
            for (i, (name, ty)) in wasm_params.iter().enumerate() {
                if i > 0 { write!(output, ", ").unwrap(); }
                write!(output, "{name}: {ty}").unwrap();
            }
            let _ = ret_class;
            writeln!(output, ") -> {wasm_ret};").unwrap();
        }
    }
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Generate dispatch wrappers
    for table in &tables {
        for func in &table.functions {
            let classes = classify_params(func, &table.module_name, &overrides);
            let ret_class = classify_return(&func.return_type);
            generate_dispatch_wrapper(&mut output, table, func, &classes, &ret_class);
        }
    }

    let out_dir = env::var("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir).join("ffi_dispatch.rs");
    fs::write(&out_path, &output).expect("Failed to write ffi_dispatch.rs");
}

// ---------------------------------------------------------------------------
// WASM import parameter list
// ---------------------------------------------------------------------------

fn build_wasm_import_params(
    params: &[ApiParam],
    classes: &[ParamClass],
) -> Vec<(String, String)> {
    let mut result = Vec::new();
    for (i, (_param, class)) in params.iter().zip(classes.iter()).enumerate() {
        match class {
            ParamClass::PtrHandle | ParamClass::ValueHandle => {
                result.push((format!("p{i}"), "i64".into()));
            }
            ParamClass::Scalar => {
                let wasm_ty = scalar_wasm_type(&params[i].ty);
                result.push((format!("p{i}"), wasm_ty));
            }
            ParamClass::ErrorCode => {
                result.push((format!("p{i}"), "i32".into()));
            }
            ParamClass::WasmBufRead { .. } | ParamClass::WasmBufWrite { .. } => {
                result.push((format!("p{i}"), "i32".into()));
            }
            ParamClass::BufLen => {
                result.push((format!("p{i}"), "i32".into()));
            }
            ParamClass::ScalarOut | ParamClass::HandleOut => {
                result.push((format!("p{i}"), "i32".into()));
            }
            ParamClass::NativePtr | ParamClass::NamedStructPtr => {
                result.push((format!("p{i}"), "i64".into()));
            }
        }
    }
    result
}

fn build_wasm_return_type(ret: &Option<ApiType>) -> String {
    match ret {
        None => "()".into(),
        Some(ty) => match ty {
            ApiType::Bool | ApiType::U8 | ApiType::U16 | ApiType::U32 | ApiType::I32 => {
                "i32".into()
            }
            ApiType::U64 | ApiType::I64 => "i64".into(),
            ApiType::F32 => "f32".into(),
            ApiType::F64 => "f64".into(),
            ApiType::UikaErrorCode => "i32".into(),
            ApiType::UObjectHandle
            | ApiType::UClassHandle
            | ApiType::FPropertyHandle
            | ApiType::UFunctionHandle
            | ApiType::UStructHandle
            | ApiType::FNameHandle
            | ApiType::FWeakObjectHandle => "i64".into(),
            ApiType::Ptr { .. } | ApiType::CVoidPtr { .. } | ApiType::NamedStructPtr { .. } => {
                "i64".into()
            }
        },
    }
}

fn scalar_wasm_type(ty: &ApiType) -> String {
    match ty {
        ApiType::Bool | ApiType::U8 | ApiType::U16 | ApiType::U32 | ApiType::I32 => "i32".into(),
        ApiType::U64 | ApiType::I64 => "i64".into(),
        ApiType::F32 => "f32".into(),
        ApiType::F64 => "f64".into(),
        _ => panic!("not a scalar type: {ty:?}"),
    }
}

// ---------------------------------------------------------------------------
// Dispatch wrapper generation
// ---------------------------------------------------------------------------

fn generate_dispatch_wrapper(
    out: &mut String,
    table: &SubTable,
    func: &ApiFn,
    classes: &[ParamClass],
    ret_class: &ParamClass,
) {
    let fn_name = format!("{}_{}", table.module_name, func.name);
    let import_name = format!("uika_{}_{}", table.module_name, func.name);

    // Build Rust-side parameter list (same as native signature, except NativePtr)
    let rust_params = build_rust_params(&func.params, classes);

    // Return type (NativePtr for native pointer returns)
    let rust_ret = build_rust_return(&func.return_type, ret_class);

    writeln!(out, "#[inline(always)]").unwrap();
    write!(out, "pub unsafe fn {fn_name}(").unwrap();
    for (i, (name, ty)) in rust_params.iter().enumerate() {
        if i > 0 { write!(out, ", ").unwrap(); }
        write!(out, "{name}: {ty}").unwrap();
    }
    writeln!(out, ") -> {rust_ret} {{").unwrap();

    // Native branch
    writeln!(out, "    #[cfg(not(target_arch = \"wasm32\"))]").unwrap();
    write!(out, "    {{ ((*crate::api::api().{}).{})(", table.module_name, func.name).unwrap();
    for (i, (name, _ty)) in rust_params.iter().enumerate() {
        if i > 0 { write!(out, ", ").unwrap(); }
        // NativePtr → *mut u8 cast on native
        if matches!(classes.get(i), Some(ParamClass::NativePtr)) {
            write!(out, "{name} as *mut u8").unwrap();
        } else if matches!(classes.get(i), Some(ParamClass::NamedStructPtr)) {
            // NamedStructPtr: on native, the param IS the right pointer type, cast from i64
            let struct_info = match &func.params[i].ty {
                ApiType::NamedStructPtr { name: sn, mutability } => {
                    let qual = if *mutability == Mutability::Const { "*const" } else { "*mut" };
                    format!("{name} as {qual} uika_ffi::reify_types::{sn}")
                }
                _ => name.clone(),
            };
            write!(out, "{struct_info}").unwrap();
        } else {
            write!(out, "{name}").unwrap();
        }
    }
    writeln!(out, ") }}").unwrap();

    // WASM branch
    writeln!(out, "    #[cfg(target_arch = \"wasm32\")]").unwrap();
    writeln!(out, "    {{").unwrap();

    // Convert args to wasm types
    let mut wasm_args = Vec::new();
    for (i, (name, _ty)) in rust_params.iter().enumerate() {
        let class = &classes[i];
        let arg = match class {
            ParamClass::PtrHandle => format!("{name}.0 as i64"),
            ParamClass::ValueHandle => {
                match &func.params[i].ty {
                    ApiType::FNameHandle => format!("{name}.0 as i64"),
                    ApiType::FWeakObjectHandle => {
                        format!("core::mem::transmute::<FWeakObjectHandle, i64>({name})")
                    }
                    _ => format!("{name}.0 as i64"),
                }
            }
            ParamClass::Scalar => {
                match &func.params[i].ty {
                    ApiType::Bool => format!("{name} as i32"),
                    ApiType::U8 | ApiType::U16 | ApiType::U32 => format!("{name} as i32"),
                    ApiType::I32 => name.clone(),
                    ApiType::U64 => format!("{name} as i64"),
                    ApiType::I64 => name.clone(),
                    ApiType::F32 | ApiType::F64 => name.clone(),
                    _ => format!("{name} as i32"),
                }
            }
            ParamClass::ErrorCode => format!("{name} as u32 as i32"),
            ParamClass::WasmBufRead { .. } | ParamClass::WasmBufWrite { .. } => {
                format!("{name} as i32")
            }
            ParamClass::BufLen => format!("{name} as i32"),
            ParamClass::ScalarOut | ParamClass::HandleOut => {
                format!("{name} as i32")
            }
            ParamClass::NativePtr => format!("{name} as i64"),
            ParamClass::NamedStructPtr => format!("{name} as i64"),
        };
        wasm_args.push(arg);
    }

    // Call and convert result
    let args_str = wasm_args.join(", ");
    match &func.return_type {
        None => {
            writeln!(out, "        {import_name}({args_str})").unwrap();
        }
        Some(ret_ty) => {
            writeln!(out, "        let __r = {import_name}({args_str});").unwrap();
            let conv = wasm_result_to_rust(ret_ty, ret_class, "__r");
            writeln!(out, "        {conv}").unwrap();
        }
    }

    writeln!(out, "    }}").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();
}

fn build_rust_params(params: &[ApiParam], classes: &[ParamClass]) -> Vec<(String, String)> {
    let mut result = Vec::new();
    for (i, (param, class)) in params.iter().zip(classes.iter()).enumerate() {
        let (name, ty) = match class {
            ParamClass::PtrHandle => {
                (format!("p{i}"), handle_type_str(&param.ty).into())
            }
            ParamClass::ValueHandle => {
                (format!("p{i}"), handle_type_str(&param.ty).into())
            }
            ParamClass::Scalar => {
                (format!("p{i}"), scalar_rust_type(&param.ty).into())
            }
            ParamClass::ErrorCode => {
                (format!("p{i}"), "UikaErrorCode".into())
            }
            ParamClass::WasmBufRead { .. } => {
                (format!("p{i}"), "*const u8".into())
            }
            ParamClass::WasmBufWrite { .. } => {
                (format!("p{i}"), "*mut u8".into())
            }
            ParamClass::BufLen => {
                (format!("p{i}"), "u32".into())
            }
            ParamClass::ScalarOut => {
                let pointee = match &param.ty {
                    ApiType::Ptr { pointee, .. } => pointee,
                    _ => unreachable!(),
                };
                let ty = format!("*mut {}", scalar_rust_type(pointee));
                (format!("p{i}"), ty)
            }
            ParamClass::HandleOut => {
                let pointee = match &param.ty {
                    ApiType::Ptr { pointee, .. } => pointee,
                    _ => unreachable!(),
                };
                let ty = format!("*mut {}", handle_type_str(pointee));
                (format!("p{i}"), ty)
            }
            ParamClass::NativePtr => {
                (format!("p{i}"), "NativePtr".into())
            }
            ParamClass::NamedStructPtr => {
                // On native, this is a typed pointer. Use i64 on both sides
                // since the pointer is opaque to Rust guest on wasm32.
                let ty = match &param.ty {
                    ApiType::NamedStructPtr { name, mutability } => {
                        let qual = if *mutability == Mutability::Const {
                            "*const"
                        } else {
                            "*mut"
                        };
                        format!("{qual} uika_ffi::reify_types::{name}")
                    }
                    _ => unreachable!(),
                };
                (format!("p{i}"), ty)
            }
        };
        result.push((name, ty));
    }
    result
}

fn build_rust_return(ret: &Option<ApiType>, class: &ParamClass) -> String {
    match ret {
        None => "()".into(),
        Some(ty) => {
            if matches!(class, ParamClass::NativePtr) {
                return "NativePtr".into();
            }
            match ty {
                ApiType::Bool => "bool".into(),
                ApiType::U8 => "u8".into(),
                ApiType::U16 => "u16".into(),
                ApiType::U32 => "u32".into(),
                ApiType::I32 => "i32".into(),
                ApiType::U64 => "u64".into(),
                ApiType::I64 => "i64".into(),
                ApiType::F32 => "f32".into(),
                ApiType::F64 => "f64".into(),
                ApiType::UikaErrorCode => "UikaErrorCode".into(),
                ApiType::UObjectHandle => "UObjectHandle".into(),
                ApiType::UClassHandle => "UClassHandle".into(),
                ApiType::FPropertyHandle => "FPropertyHandle".into(),
                ApiType::UFunctionHandle => "UFunctionHandle".into(),
                ApiType::UStructHandle => "UStructHandle".into(),
                ApiType::FNameHandle => "FNameHandle".into(),
                ApiType::FWeakObjectHandle => "FWeakObjectHandle".into(),
                ApiType::Ptr { mutability: Mutability::Mut, .. } => "NativePtr".into(),
                _ => "i64".into(),
            }
        }
    }
}

fn wasm_result_to_rust(ty: &ApiType, _class: &ParamClass, var: &str) -> String {
    match ty {
        ApiType::Bool => format!("{var} != 0"),
        ApiType::U8 => format!("{var} as u8"),
        ApiType::U16 => format!("{var} as u16"),
        ApiType::U32 => format!("{var} as u32"),
        ApiType::I32 => format!("{var}"),
        ApiType::U64 => format!("{var} as u64"),
        ApiType::I64 => format!("{var}"),
        ApiType::F32 => format!("{var}"),
        ApiType::F64 => format!("{var}"),
        ApiType::UikaErrorCode => format!("core::mem::transmute({var} as u32)"),
        ApiType::UObjectHandle => format!("UObjectHandle({var} as u64)"),
        ApiType::UClassHandle => format!("UClassHandle({var} as u64)"),
        ApiType::FPropertyHandle => format!("FPropertyHandle({var} as u64)"),
        ApiType::UFunctionHandle => format!("UFunctionHandle({var} as u64)"),
        ApiType::UStructHandle => format!("UStructHandle({var} as u64)"),
        ApiType::FNameHandle => format!("FNameHandle({var} as u64)"),
        ApiType::FWeakObjectHandle => {
            format!("core::mem::transmute::<i64, FWeakObjectHandle>({var})")
        }
        // Native pointer return
        ApiType::Ptr { mutability: Mutability::Mut, .. } => format!("{var} as u64"),
        _ => format!("{var} as i64"),
    }
}

fn handle_type_str(ty: &ApiType) -> &str {
    match ty {
        ApiType::UObjectHandle => "UObjectHandle",
        ApiType::UClassHandle => "UClassHandle",
        ApiType::FPropertyHandle => "FPropertyHandle",
        ApiType::UFunctionHandle => "UFunctionHandle",
        ApiType::UStructHandle => "UStructHandle",
        ApiType::FNameHandle => "FNameHandle",
        ApiType::FWeakObjectHandle => "FWeakObjectHandle",
        _ => panic!("not a handle: {ty:?}"),
    }
}

fn scalar_rust_type(ty: &ApiType) -> &str {
    match ty {
        ApiType::Bool => "bool",
        ApiType::U8 => "u8",
        ApiType::U16 => "u16",
        ApiType::U32 => "u32",
        ApiType::I32 => "i32",
        ApiType::U64 => "u64",
        ApiType::I64 => "i64",
        ApiType::F32 => "f32",
        ApiType::F64 => "f64",
        _ => panic!("not a scalar: {ty:?}"),
    }
}
