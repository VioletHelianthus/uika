//! Generates `host_functions_generated.rs` from `uika-ffi/src/api_table.rs`.
//!
//! For each sub-table function, generates a `linker.func_wrap(...)` call that:
//! 1. Receives WASM-typed arguments (i32/i64/f32/f64)
//! 2. Converts handles and reads/writes WASM memory as needed
//! 3. Calls the actual C++ API via the UikaApiTable

use std::env;
use std::fmt::Write as FmtWrite;
use std::fs;
use std::path::Path;

use uika_api_parse::*;

fn main() {
    let api_table_path = Path::new("../uika-ffi/src/api_table.rs");
    println!("cargo:rerun-if-changed={}", api_table_path.display());
    println!("cargo:rerun-if-changed=native_ptr_overrides.toml");

    let source = fs::read_to_string(api_table_path)
        .expect("Failed to read api_table.rs");
    let tables = parse_api_table(&source);

    let overrides_toml = fs::read_to_string("native_ptr_overrides.toml")
        .unwrap_or_default();
    let overrides = NativePtrOverrides::from_toml(&overrides_toml);

    let mut output = String::new();
    writeln!(output, "// Auto-generated by uika-wasm-host/build.rs — do not edit").unwrap();
    writeln!(output, "// Source: uika-ffi/src/api_table.rs").unwrap();
    writeln!(output).unwrap();

    // Generate register_all_host_functions
    writeln!(output, "pub fn register_all_host_functions(").unwrap();
    writeln!(output, "    linker: &mut Linker<HostState>,").unwrap();
    writeln!(output, ") -> wasmtime::Result<()> {{").unwrap();
    for table in &tables {
        writeln!(output, "    register_{}(linker)?;", table.module_name).unwrap();
    }
    writeln!(output, "    Ok(())").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Generate per-module registration functions
    for table in &tables {
        generate_module_registration(&mut output, table, &overrides);
    }

    let out_dir = env::var("OUT_DIR").unwrap();
    let out_path = Path::new(&out_dir).join("host_functions_generated.rs");
    fs::write(&out_path, &output).expect("Failed to write generated host functions");
}

fn generate_module_registration(out: &mut String, table: &SubTable, overrides: &NativePtrOverrides) {
    writeln!(out, "fn register_{}(linker: &mut Linker<HostState>) -> wasmtime::Result<()> {{", table.module_name).unwrap();

    for func in &table.functions {
        let import_name = format!("uika_{}_{}", table.module_name, func.name);
        let param_classes = classify_params(func, &table.module_name, overrides);
        let ret_class = classify_return(&func.return_type);

        // Build WASM parameter list and return type
        let wasm_params = build_wasm_params(&func.params, &param_classes);
        let wasm_ret = build_wasm_return(&func.return_type, &ret_class);

        // Generate the host function body
        writeln!(out, "    linker.func_wrap(\"uika\", \"{import_name}\", {{").unwrap();

        // Determine if we need `mut caller` (for WASM memory writes)
        let needs_mut_caller = param_classes.iter().any(|c| matches!(c,
            ParamClass::WasmBufWrite { .. } | ParamClass::ScalarOut | ParamClass::HandleOut
        ));

        let caller_binding = if needs_mut_caller { "mut caller" } else { "caller" };

        // Function signature
        write!(out, "        |{caller_binding}: Caller<'_, HostState>").unwrap();
        for (wp_name, wp_type) in &wasm_params {
            write!(out, ", {wp_name}: {wp_type}").unwrap();
        }
        write!(out, "| -> {wasm_ret} {{\n").unwrap();

        // Get API pointer
        writeln!(out, "            let api = caller.data().api;").unwrap();
        writeln!(out, "            unsafe {{").unwrap();
        writeln!(out, "                let sub = &*(*api).{};", table.module_name).unwrap();

        // Convert WASM params to native types
        let mut native_args = Vec::new();
        let mut buf_vars = Vec::new(); // temp buffer variables
        let mut wasm_param_idx = 0;

        for (i, (param, class)) in func.params.iter().zip(param_classes.iter()).enumerate() {
            let wp = &wasm_params;
            match class {
                ParamClass::PtrHandle => {
                    let handle_type = handle_type_name(&param.ty);
                    let wp_name = &wp[wasm_param_idx].0;
                    writeln!(out, "                let arg_{i} = {handle_type}({wp_name} as usize as *mut c_void);").unwrap();
                    native_args.push(format!("arg_{i}"));
                    wasm_param_idx += 1;
                }
                ParamClass::ValueHandle => {
                    let wp_name = &wp[wasm_param_idx].0;
                    match &param.ty {
                        ApiType::FNameHandle => {
                            writeln!(out, "                let arg_{i} = FNameHandle({wp_name} as u64);").unwrap();
                        }
                        ApiType::FWeakObjectHandle => {
                            writeln!(out, "                let arg_{i}: FWeakObjectHandle = std::mem::transmute({wp_name} as u64);").unwrap();
                        }
                        _ => unreachable!(),
                    }
                    native_args.push(format!("arg_{i}"));
                    wasm_param_idx += 1;
                }
                ParamClass::Scalar => {
                    let wp_name = &wp[wasm_param_idx].0;
                    let cast = scalar_from_wasm(&param.ty, wp_name);
                    writeln!(out, "                let arg_{i} = {cast};").unwrap();
                    native_args.push(format!("arg_{i}"));
                    wasm_param_idx += 1;
                }
                ParamClass::ErrorCode => {
                    let wp_name = &wp[wasm_param_idx].0;
                    writeln!(out, "                let arg_{i}: UikaErrorCode = std::mem::transmute({wp_name} as u32);").unwrap();
                    native_args.push(format!("arg_{i}"));
                    wasm_param_idx += 1;
                }
                ParamClass::WasmBufRead { len_param_index: _ } => {
                    let ptr_name = &wp[wasm_param_idx].0;
                    let len_name = &wp[wasm_param_idx + 1].0;
                    let buf_var = format!("buf_{i}");
                    writeln!(out, "                let {buf_var} = crate::wasm_host::read_guest_bytes(&caller, {ptr_name} as u32, {len_name} as u32);").unwrap();
                    native_args.push(format!("{buf_var}.as_ptr()"));
                    wasm_param_idx += 2;
                }
                ParamClass::BufLen => {
                    // Already consumed by preceding WasmBufRead/Write.
                    // Push the len value — use matching variable prefix.
                    let prev_buf_idx = i - 1;
                    let prefix = match &param_classes[prev_buf_idx] {
                        ParamClass::WasmBufWrite { .. } => "wbuf",
                        _ => "buf",
                    };
                    native_args.push(format!("{prefix}_{prev_buf_idx}.len() as u32"));
                }
                ParamClass::WasmBufWrite { len_param_index: _ } => {
                    let ptr_name = &wp[wasm_param_idx].0;
                    let len_name = &wp[wasm_param_idx + 1].0;
                    let buf_var = format!("wbuf_{i}");
                    writeln!(out, "                let mut {buf_var} = vec![0u8; {len_name} as usize];").unwrap();
                    native_args.push(format!("{buf_var}.as_mut_ptr()"));
                    buf_vars.push((i, format!("{ptr_name}"), format!("{len_name}")));
                    wasm_param_idx += 2;
                }
                ParamClass::ScalarOut => {
                    let pointee = match &param.ty {
                        ApiType::Ptr { pointee, .. } => pointee,
                        _ => unreachable!(),
                    };
                    let rust_type = rust_type_name(pointee);
                    let var = format!("out_{i}");
                    writeln!(out, "                let mut {var}: {rust_type} = Default::default();").unwrap();
                    native_args.push(format!("&mut {var}"));
                    // Store wp index for later write-back
                    buf_vars.push((i, wp[wasm_param_idx].0.clone(), String::new()));
                    wasm_param_idx += 1;
                }
                ParamClass::HandleOut => {
                    let pointee = match &param.ty {
                        ApiType::Ptr { pointee, .. } => pointee,
                        _ => unreachable!(),
                    };
                    let var = format!("out_{i}");
                    let null_expr = handle_null_expr(pointee);
                    writeln!(out, "                let mut {var} = {null_expr};").unwrap();
                    native_args.push(format!("&mut {var}"));
                    buf_vars.push((i, wp[wasm_param_idx].0.clone(), String::new()));
                    wasm_param_idx += 1;
                }
                ParamClass::NativePtr => {
                    let wp_name = &wp[wasm_param_idx].0;
                    writeln!(out, "                let arg_{i} = {wp_name} as usize as *mut u8;").unwrap();
                    native_args.push(format!("arg_{i}"));
                    wasm_param_idx += 1;
                }
                ParamClass::NamedStructPtr => {
                    let wp_name = &wp[wasm_param_idx].0;
                    let struct_name = match &param.ty {
                        ApiType::NamedStructPtr { name, mutability } => {
                            let qual = if *mutability == Mutability::Const { "*const" } else { "*mut" };
                            format!("{wp_name} as usize as {qual} uika_ffi::reify_types::{name}")
                        }
                        _ => unreachable!(),
                    };
                    writeln!(out, "                let arg_{i} = {struct_name};").unwrap();
                    native_args.push(format!("arg_{i}"));
                    wasm_param_idx += 1;
                }
            }
        }

        // Call the API function
        let args_str = native_args.join(", ");
        let has_return = func.return_type.is_some();
        if has_return {
            writeln!(out, "                let result = (sub.{})({args_str});", func.name).unwrap();
        } else {
            writeln!(out, "                (sub.{})({args_str});", func.name).unwrap();
        }

        // Write back out-params to WASM memory
        for (param_idx, wp_name, _wp_len) in &buf_vars {
            let class = &param_classes[*param_idx];
            match class {
                ParamClass::WasmBufWrite { .. } => {
                    writeln!(out, "                crate::wasm_host::write_guest_bytes(&mut caller, {wp_name} as u32, &wbuf_{param_idx});").unwrap();
                }
                ParamClass::ScalarOut => {
                    let pointee = match &func.params[*param_idx].ty {
                        ApiType::Ptr { pointee, .. } => pointee,
                        _ => unreachable!(),
                    };
                    // bool doesn't have to_ne_bytes(), convert to u8 first
                    if **pointee == ApiType::Bool {
                        writeln!(out, "                crate::wasm_host::write_guest_bytes(&mut caller, {wp_name} as u32, &[out_{param_idx} as u8]);").unwrap();
                    } else {
                        writeln!(out, "                crate::wasm_host::write_guest_bytes(&mut caller, {wp_name} as u32, &out_{param_idx}.to_ne_bytes());").unwrap();
                    }
                }
                ParamClass::HandleOut => {
                    // Write handle as i64 to WASM memory
                    writeln!(out, "                crate::wasm_host::write_guest_bytes(&mut caller, {wp_name} as u32, &(out_{param_idx}.0 as usize as i64).to_ne_bytes());").unwrap();
                }
                _ => {}
            }
        }

        // Return value
        if let Some(ref ret_type) = func.return_type {
            let ret_expr = return_to_wasm(ret_type, &ret_class, "result");
            writeln!(out, "                {ret_expr}").unwrap();
        }

        writeln!(out, "            }}").unwrap(); // unsafe
        writeln!(out, "        }}").unwrap(); // closure
        writeln!(out, "    }})?;").unwrap(); // func_wrap
        writeln!(out).unwrap();
    }

    writeln!(out, "    Ok(())").unwrap();
    writeln!(out, "}}").unwrap();
    writeln!(out).unwrap();
}

// ---------------------------------------------------------------------------
// Code generation helpers
// ---------------------------------------------------------------------------

/// Build WASM parameter list: (name, wasm_type) pairs.
fn build_wasm_params(params: &[ApiParam], classes: &[ParamClass]) -> Vec<(String, String)> {
    let mut result = Vec::new();
    for (i, (param, class)) in params.iter().zip(classes.iter()).enumerate() {
        match class {
            ParamClass::BufLen => {
                // Already consumed by preceding buffer param — still need to declare it
                result.push((format!("p_{i}"), "i32".to_string()));
            }
            ParamClass::WasmBufRead { .. } | ParamClass::WasmBufWrite { .. } => {
                // ptr param
                result.push((format!("p_{i}"), "i32".to_string()));
                // len param will be added by BufLen
            }
            ParamClass::ScalarOut | ParamClass::HandleOut => {
                result.push((format!("p_{i}"), "i32".to_string())); // WASM memory offset
            }
            _ => {
                let wasm_type = api_type_to_wasm(&param.ty);
                result.push((format!("p_{i}"), wasm_type));
            }
        }
    }
    result
}

fn build_wasm_return(ret: &Option<ApiType>, _class: &ParamClass) -> String {
    match ret {
        None => "()".to_string(),
        Some(ty) => api_type_to_wasm(ty),
    }
}

fn api_type_to_wasm(ty: &ApiType) -> String {
    match ty {
        ApiType::UObjectHandle | ApiType::UClassHandle | ApiType::FPropertyHandle
        | ApiType::UFunctionHandle | ApiType::UStructHandle
        | ApiType::FNameHandle | ApiType::FWeakObjectHandle => "i64".to_string(),
        ApiType::Bool | ApiType::U8 | ApiType::U16 | ApiType::U32 | ApiType::I32 => "i32".to_string(),
        ApiType::U64 | ApiType::I64 => "i64".to_string(),
        ApiType::F32 => "f32".to_string(),
        ApiType::F64 => "f64".to_string(),
        ApiType::UikaErrorCode => "i32".to_string(),
        ApiType::Ptr { .. } | ApiType::CVoidPtr { .. } | ApiType::NamedStructPtr { .. } => "i64".to_string(),
    }
}

fn handle_type_name(ty: &ApiType) -> &str {
    match ty {
        ApiType::UObjectHandle => "UObjectHandle",
        ApiType::UClassHandle => "UClassHandle",
        ApiType::FPropertyHandle => "FPropertyHandle",
        ApiType::UFunctionHandle => "UFunctionHandle",
        ApiType::UStructHandle => "UStructHandle",
        ApiType::FNameHandle => "FNameHandle",
        _ => panic!("not a handle type: {ty:?}"),
    }
}

fn rust_type_name(ty: &ApiType) -> &str {
    match ty {
        ApiType::Bool => "bool",
        ApiType::U8 => "u8",
        ApiType::U16 => "u16",
        ApiType::U32 => "u32",
        ApiType::U64 => "u64",
        ApiType::I32 => "i32",
        ApiType::I64 => "i64",
        ApiType::F32 => "f32",
        ApiType::F64 => "f64",
        _ => panic!("not a scalar type: {ty:?}"),
    }
}

fn scalar_from_wasm(ty: &ApiType, var: &str) -> String {
    match ty {
        ApiType::Bool => format!("{var} != 0"),
        ApiType::U8 => format!("{var} as u8"),
        ApiType::U16 => format!("{var} as u16"),
        ApiType::U32 => format!("{var} as u32"),
        ApiType::I32 => format!("{var}"),
        ApiType::U64 => format!("{var} as u64"),
        ApiType::I64 => format!("{var}"),
        ApiType::F32 => format!("{var}"),
        ApiType::F64 => format!("{var}"),
        _ => panic!("not a scalar type for WASM conversion: {ty:?}"),
    }
}

fn return_to_wasm(ty: &ApiType, _class: &ParamClass, var: &str) -> String {
    match ty {
        ApiType::Bool => format!("if {var} {{ 1i32 }} else {{ 0i32 }}"),
        ApiType::U8 => format!("{var} as i32"),
        ApiType::U16 => format!("{var} as i32"),
        ApiType::U32 => format!("{var} as i32"),
        ApiType::I32 => format!("{var}"),
        ApiType::U64 => format!("{var} as i64"),
        ApiType::I64 => format!("{var}"),
        ApiType::F32 => format!("{var}"),
        ApiType::F64 => format!("{var}"),
        ApiType::UikaErrorCode => format!("{var} as u32 as i32"),
        ApiType::UObjectHandle | ApiType::UClassHandle | ApiType::FPropertyHandle
        | ApiType::UFunctionHandle | ApiType::UStructHandle => {
            format!("{var}.0 as usize as i64")
        }
        ApiType::FNameHandle => format!("{var}.0 as i64"),
        ApiType::FWeakObjectHandle => format!("std::mem::transmute::<FWeakObjectHandle, i64>({var})"),
        ApiType::Ptr { mutability: Mutability::Mut, .. } => {
            format!("{var} as usize as i64") // native pointer pass-through
        }
        _ => format!("{var} as i64"),
    }
}

/// Returns the "null" initializer expression for a handle type.
fn handle_null_expr(ty: &ApiType) -> &str {
    match ty {
        // Pointer handles have ::null() from define_ptr_handle! macro
        ApiType::UObjectHandle | ApiType::UClassHandle | ApiType::FPropertyHandle
        | ApiType::UFunctionHandle | ApiType::UStructHandle => {
            // handle_type_name(ty) + "::null()" — but we need a static str,
            // so match each one individually
            match ty {
                ApiType::UObjectHandle => "UObjectHandle::null()",
                ApiType::UClassHandle => "UClassHandle::null()",
                ApiType::FPropertyHandle => "FPropertyHandle::null()",
                ApiType::UFunctionHandle => "UFunctionHandle::null()",
                ApiType::UStructHandle => "UStructHandle::null()",
                _ => unreachable!(),
            }
        }
        // Value handles — use literal zero initialization
        ApiType::FNameHandle => "FNameHandle(0)",
        ApiType::FWeakObjectHandle => "unsafe { std::mem::transmute::<u64, FWeakObjectHandle>(0u64) }",
        _ => panic!("not a handle type: {ty:?}"),
    }
}
