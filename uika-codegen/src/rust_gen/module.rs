// Module file generation (mod.rs per module, lib.rs top-level).

use crate::context::CodegenContext;
use crate::naming::{is_reserved, to_snake_case};
use crate::schema::{ClassInfo, EnumInfo, StructInfo};

/// Generate a module's `mod.rs` with all sub-module declarations and re-exports.
pub fn generate_module_mod(
    _module_name: &str,
    enums: Option<&[EnumInfo]>,
    structs: Option<&[StructInfo]>,
    classes: Option<&[ClassInfo]>,
) -> String {
    let mut out = String::with_capacity(4096);
    out.push_str("// Auto-generated by uika-codegen. Do not edit.\n\n");

    // Enum modules
    if let Some(enums) = enums {
        for e in enums {
            let mod_name = to_snake_case(&e.name);
            write_mod_use(&mut out, &mod_name);
        }
    }

    // Struct modules
    if let Some(structs) = structs {
        for s in structs {
            let mod_name = to_snake_case(&s.name);
            write_mod_use(&mut out, &mod_name);
        }
    }

    // Class modules
    if let Some(classes) = classes {
        for c in classes {
            let mod_name = to_snake_case(&c.name);
            write_mod_use(&mut out, &mod_name);
        }
    }

    out
}

/// Write `mod foo; pub use foo::*;` handling keyword escaping.
/// File on disk is named `foo.rs` but in code we use `r#foo` if needed.
fn write_mod_use(out: &mut String, mod_name: &str) {
    if is_reserved(mod_name) {
        // Use #[path] attribute to map the keyword module name to its file
        out.push_str(&format!("#[path = \"{mod_name}.rs\"]\n"));
        out.push_str(&format!("mod r#{mod_name};\n"));
        out.push_str(&format!("pub use r#{mod_name}::*;\n\n"));
    } else {
        out.push_str(&format!("mod {mod_name};\n"));
        out.push_str(&format!("pub use {mod_name}::*;\n\n"));
    }
}

/// Generate the top-level `lib.rs` with module declarations gated by features.
pub fn generate_lib_rs(ctx: &CodegenContext) -> String {
    let mut out = String::with_capacity(1024);
    out.push_str("// Auto-generated by uika-codegen. Do not edit.\n\n");
    out.push_str("#![allow(non_camel_case_types, non_snake_case, dead_code, unused_imports)]\n\n");
    out.push_str("pub mod func_ids;\n\n");

    // Sort modules for deterministic output
    let mut modules: Vec<&String> = ctx.enabled_modules.iter().collect();
    modules.sort();

    for module in modules {
        if let Some(feature) = ctx.feature_for_module(module) {
            out.push_str(&format!(
                "#[cfg(feature = \"{feature}\")]\npub mod {module};\n\n"
            ));
        } else {
            out.push_str(&format!("pub mod {module};\n\n"));
        }
    }

    // Hand-written manual override module (not generated).
    out.push_str("pub mod manual;\n\n");

    out
}
